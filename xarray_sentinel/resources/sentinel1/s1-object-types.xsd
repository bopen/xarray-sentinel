<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id: s1-object-types.xsd 10572 2014-05-29 18:24:38Z cthain $ -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
	<!--
    ========================================================================
    = Common product type definitions
    ======================================================================== 
    -->
	<xsd:simpleType name="absOrbitNumberType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned int SPF_ObjectTypes_AbsOrbitNumberType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Absolute orbit number type.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:pattern value="[1-9][0-9]{0,5}"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="adsHeaderType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
/*
 * XmlConvert function for the SPF_ObjectTypes_AdsHeaderType structure.
 */
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_AdsHeaderType&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/missionId" );
   if( XRW_Convert_Enum( op,
                         xmlTreeDescriptor,
                         xmlFieldPath,
                         value.missionId,
                         SPF_ObjectTypes_MissionIdTypeStringList,
                         SPF_ObjectTypes_MissionIdTypeStringListSize )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/productType" );
   if( XRW_Convert_Enum( op,
                         xmlTreeDescriptor,
                         xmlFieldPath,
                         value.productType,
                         SPF_ObjectTypes_ProductTypeStringList,
                         SPF_ObjectTypes_ProductTypeStringListSize )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/polarisation" );
   if( XRW_Convert_Enum( op,
                         xmlTreeDescriptor,
                         xmlFieldPath,
                         value.polarisation,
                         SPF_ObjectTypes_PolarisationTypeStringList,
                         SPF_ObjectTypes_PolarisationTypeStringListSize )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/mode" );
   if( XRW_Convert_Enum( op,
                         xmlTreeDescriptor,
                         xmlFieldPath,
                         value.mode,
                         SPF_ObjectTypes_SensorModeTypeStringList,
                         SPF_ObjectTypes_SensorModeTypeStringListSize )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/swath" );
   if( XRW_Convert_Enum( op,
                         xmlTreeDescriptor,
                         xmlFieldPath,
                         value.swath,
                         SPF_ObjectTypes_SwathTypeStringList,
                         SPF_ObjectTypes_SwathTypeStringListSize )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/startTime" );
   if( XmlConvert( op, xmlTreeDescriptor, xmlFieldPath, value.startTime )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/stopTime" );
   if( XmlConvert( op, xmlTreeDescriptor, xmlFieldPath, value.stopTime )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/absoluteOrbitNumber" );
   if( XRW_Convert( op, xmlTreeDescriptor, xmlFieldPath, value.absoluteOrbitNumber )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/missionDataTakeId" );
   if( XRW_Convert( op, xmlTreeDescriptor, xmlFieldPath, value.missionDataTakeId )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/imageNumber" );
   if( XRW_Convert( op, xmlTreeDescriptor, xmlFieldPath, value.imageNumber, "%.3d" )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Common header for all Annotation Data Sets. This record contains the three elements - polarisation, swath and imageNumber - used to identify Annotation Data Sets and link them to the appropriate Measurement Data Set.</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="missionId" type="missionIdType">
				<xsd:annotation>
					<xsd:documentation>Mission identifier for this data set.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="productType" type="productType">
				<xsd:annotation>
					<xsd:documentation>Product type for this data set.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="polarisation" type="polarisationType">
				<xsd:annotation>
					<xsd:documentation>Polarisation for this data set. </xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="mode" type="sensorModeType">
				<xsd:annotation>
					<xsd:documentation>Sensor mode for this data set. The sensorMode type are S1-S6, IW, EW, WV, and IM.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="swath" type="swathType">
				<xsd:annotation>
					<xsd:documentation>Swath identifier for this data set. This element identifies the swath that applies to all data contained within this data set.  The swath identifier "EW" is used for products in which the 5 EW swaths have been merged.  Likewise, "IW" is used for products in which the 3 IW swaths have been merged.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="startTime" type="timeType">
				<xsd:annotation>
					<xsd:documentation>Zero Doppler start time of the output image [UTC]. </xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="stopTime" type="timeType">
				<xsd:annotation>
					<xsd:documentation>Zero Doppler stop time of the output image [UTC].</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="absoluteOrbitNumber" type="absOrbitNumberType">
				<xsd:annotation>
					<xsd:documentation>Absolute orbit number at data set start time.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="missionDataTakeId" type="missionDataTakeIdType">
				<xsd:annotation>
					<xsd:documentation>Mission data take identifier. </xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="imageNumber" type="imageNumberType">
				<xsd:annotation>
					<xsd:documentation>Image number. For WV products the image number is used to distinguish between vignettes.  For SM, IW and EW modes the image number is still used but refers instead to each swath and polarisation combination (known as the 'channel') of the data.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
	</xsd:complexType>
	<xsd:simpleType name="aocsOpModeType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of the available AOCS operational mode from the pointing status in the downlink.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="No Mode"/>
			<xsd:enumeration value="Normal Pointing Mode"/>
			<xsd:enumeration value="Orbit Control Mode"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="bandwidthType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of the available bandwidths for SAR signals in the timeline.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Image"/>
			<xsd:enumeration value="Full"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="baqCodeType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of BAQ/FDBAQ LUT index codes.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="BAQ 3-Bit"/>
			<xsd:enumeration value="BAQ 4-Bit"/>
			<xsd:enumeration value="BAQ 5-Bit"/>
			<xsd:enumeration value="BRC 0"/>
			<xsd:enumeration value="BRC 1"/>
			<xsd:enumeration value="BRC 2"/>
			<xsd:enumeration value="BRC 3"/>
			<xsd:enumeration value="BRC 4"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="calCombinationMethodType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid methods for combining calibration pulses.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="PCC2"/>
			<xsd:enumeration value="Average"/>
			<xsd:enumeration value="Isolation Subtraction"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="checksumType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef int SPF_ObjectTypes_ChecksumType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>CRC-16 Checksum type.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:pattern value="[0-9A-F][0-9A-F][0-9A-F][0-9A-F]"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="chirpSourceType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of the available chirp schemes.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Nominal"/>
			<xsd:enumeration value="Extracted"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="pgSourceType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of the available PG schemes.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Extracted"/>
			<xsd:enumeration value="Model"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="dataFormatModeType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of compression method names.  This enumeration is a consolidated list from the Sentinel-1 SPPDU document and the ENVISAT Product Specification.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Full 8 Bit"/>
			<xsd:enumeration value="SM"/>
			<xsd:enumeration value="FBAQ 2 Bit"/>
			<xsd:enumeration value="FBAQ 3 Bit"/>
			<xsd:enumeration value="FBAQ 4 Bit"/>
			<xsd:enumeration value="FBAQ 5 Bit"/>
			<xsd:enumeration value="None"/>
			<xsd:enumeration value="FDBAQ"/>
			<xsd:enumeration value="BAQ 3 Bit"/>
			<xsd:enumeration value="BAQ 4 Bit"/>
			<xsd:enumeration value="BAQ 5 Bit"/>
			<xsd:enumeration value="Decimation"/>
			<xsd:enumeration value="Bypass"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="dcMethodType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of Doppler centroid calculation/estimation methods.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Data Analysis"/>
			<xsd:enumeration value="Orbit and Attitude"/>
			<xsd:enumeration value="Pre-defined"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="dcInputDataType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of Doppler centroid input data formats.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Raw"/>
			<xsd:enumeration value="Range Compressed"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="eccNumberType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned int SPF_ObjectTypes_EccNumberType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>ECC number type.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="unsignedInt">
			<xsd:minInclusive value="0"/>
			<xsd:maxInclusive value="47"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="imageNumberType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef int SPF_ObjectTypes_ImageNumberType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Image number type. For WV products the image number is used to distinguish between vignettes.  For SM, IW and EW modes the image number is still used but refers instead to each swath and polarisation combination (known as the 'channel') of the data.This value ranges from 001 to 999.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:pattern value="00[1-9]|0[1-9][0-9]|[1-9][0-9][0-9]"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="missionDataTakeIdType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned int SPF_ObjectTypes_MissionDataTakeIdType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Mission data take identifier.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:pattern value="[1-9][0-9]{0,5}"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="missionIdType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid Sentinel-1 mission identifiers.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="S1A"/>
			<xsd:enumeration value="S1B"/>
			<xsd:enumeration value="ASA"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="outputPixelsType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of output pixel data types.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="32 bit Float"/>
			<xsd:enumeration value="16 bit Signed Integer"/>
			<xsd:enumeration value="16 bit Unsigned Integer"/>
			<xsd:enumeration value="8 bit Unsigned Integer"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="passDirectionType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of the orbit pass direction values.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Ascending"/>
			<xsd:enumeration value="Descending"/>
			<xsd:enumeration value="ASCENDING"/>
			<xsd:enumeration value="DESCENDING"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="projectionType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of the image projection.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Slant Range"/>
			<xsd:enumeration value="Ground Range"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="pixelValueType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of output pixel value interpretaion types.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Complex"/>
			<xsd:enumeration value="Detected"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="polarisationType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid polarisations for the Sentinel-1 SAR instrument.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="HH"/>
			<xsd:enumeration value="HV"/>
			<xsd:enumeration value="VH"/>
			<xsd:enumeration value="VV"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="compositePolarisationType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid composite polarisations used for product and data set naming: SH (Single HH), SV (Single VV), DH (Dual HH/HV), DV (Dual VV/VH), HH (Partial HH), HV (Partial HV), VV (Partial VV), VH (Partial VH).</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="SH"/>
			<xsd:enumeration value="SV"/>
			<xsd:enumeration value="DH"/>
			<xsd:enumeration value="DV"/>
			<xsd:enumeration value="HH"/>
			<xsd:enumeration value="HV"/>
			<xsd:enumeration value="VV"/>
			<xsd:enumeration value="VH"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="orbitAttitudeSourceType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of value sources of orbit and attitude data. "Downlink" or "Auxiliary".</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Downlink"/>
			<xsd:enumeration value="Auxiliary"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="productCompositionType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of product composition indicators.  The valid values are: "Individual", to indicate a full non-sliced product; "Slice", to indicate that this is a single slice of a larger product; and "Assembled", to indicate that this is a product that has been created by combining multiple slices.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Individual"/>
			<xsd:enumeration value="Slice"/>
			<xsd:enumeration value="Assembled"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="processingLevelType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid processing levels.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="1"/>
			<xsd:enumeration value="2"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="productClassType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid product classes: S (Standard Product), A (Annotation Product).</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="S"/>
			<xsd:enumeration value="A"/>
			<xsd:enumeration value="N"/>
			<xsd:enumeration value="C"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="productClassDescriptionType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid product class descriptions.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="SAR Standard L0 Product"/>
			<xsd:enumeration value="SAR Annotation L0 Product"/>
			<xsd:enumeration value="SAR Standard L1 Product"/>
			<xsd:enumeration value="SAR Annotation L1 Product"/>
			<xsd:enumeration value="SAR Standard L2 Product"/>
			<xsd:enumeration value="SAR Annotation L2 Product"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="productTimelinessCategoryType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid timeliness categories.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="NRT-10m"/>
			<xsd:enumeration value="NRT-1h"/>
			<xsd:enumeration value="NRT-3h"/>
			<xsd:enumeration value="Fast-24h"/>
			<xsd:enumeration value="Off-line"/>
			<xsd:enumeration value="Reprocessing"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="productType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid product types.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="SLC"/>
			<xsd:enumeration value="GRD"/>
			<xsd:enumeration value="BRW"/>
			<xsd:enumeration value="OCN"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="productUniqueIdType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned int SPF_ObjectTypes_ProductUniqueIdType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Product unique identifier (CRC-16 checksum on manifest file).</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:pattern value="[0-9A-F][0-9A-F][0-9A-F][0-9A-F]"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="referenceFrameType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid reference frames for orbit and attitude data.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Undefined"/>
			<xsd:enumeration value="Galactic"/>
			<xsd:enumeration value="BM1950"/>
			<xsd:enumeration value="BM2000"/>
			<xsd:enumeration value="HM2000"/>
			<xsd:enumeration value="GM2000"/>
			<xsd:enumeration value="Mean Of Date"/>
			<xsd:enumeration value="True Of Date"/>
			<xsd:enumeration value="Pseudo True Of Date"/>
			<xsd:enumeration value="Earth Fixed"/>
			<xsd:enumeration value="Topocentric"/>
			<xsd:enumeration value="Satellite Orbital"/>
			<xsd:enumeration value="Satellite Nominal"/>
			<xsd:enumeration value="Satellite Attitude"/>
			<xsd:enumeration value="Instrument Attitude"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="rrfSpectrumType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid RRF types.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Unextended"/>
			<xsd:enumeration value="Extended Flat"/>
			<xsd:enumeration value="Extended Tapered"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="rxPolarisationType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid receive polarisations.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="H"/>
			<xsd:enumeration value="V"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="sensorModeType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid sensor mode abbreviations for the Sentinel-1 SAR instrument.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="S1"/>
			<xsd:enumeration value="S2"/>
			<xsd:enumeration value="S3"/>
			<xsd:enumeration value="S4"/>
			<xsd:enumeration value="S5"/>
			<xsd:enumeration value="S6"/>
			<xsd:enumeration value="IW"/>
			<xsd:enumeration value="EW"/>
			<xsd:enumeration value="WV"/>
			<xsd:enumeration value="EN"/>
			<xsd:enumeration value="N1"/>
			<xsd:enumeration value="N2"/>
			<xsd:enumeration value="N3"/>
			<xsd:enumeration value="N4"/>
			<xsd:enumeration value="N5"/>
			<xsd:enumeration value="N6"/>
			<xsd:enumeration value="RF"/>
			<xsd:enumeration value="IM"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="signalType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid signal types for the Sentinel-1 SAR instrument.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Echo"/>
			<xsd:enumeration value="Noise"/>
			<xsd:enumeration value="TxCal"/>
			<xsd:enumeration value="RxCal"/>
			<xsd:enumeration value="EpdnCal"/>
			<xsd:enumeration value="TxHCalIso"/>
			<xsd:enumeration value="TaCal"/>
			<xsd:enumeration value="ApdnCal"/>
			<xsd:enumeration value="TaRxCal"/>
			<xsd:enumeration value="ApdnRxCal"/>
			<xsd:enumeration value="TxRxOff"/>
			<xsd:enumeration value="Silent"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="swathNumberType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned int SPF_ObjectTypes_SwathNumberType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Swath number from SPPDU.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="unsignedByte">
			<xsd:maxInclusive value="127"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="swathType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of all valid swath identifiers for the Sentinel-1 SAR instrument. The S1-S6 swaths apply to SM products, the IW and IW1-3 swaths apply to IW products (IW is used for detected IW products where the 3 swaths are merged into one image), the EW and EW1-5 swaths apply to EW products (EW is used for detected EW products where the 5 swaths are merged into one image), and the WV1-2 swaths apply to WV products.  The EN, N1-N6 swaths apply to the Sentinel-1 notch modes used for instrument calibration.  The RF swath applies to the Sentinel-1 RFC mode which is not processed by the IPF.  The IS1-IS7 swaths apply to ASAR IM and WV products.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="S1"/>
			<xsd:enumeration value="S2"/>
			<xsd:enumeration value="S3"/>
			<xsd:enumeration value="S4"/>
			<xsd:enumeration value="S5"/>
			<xsd:enumeration value="S6"/>
			<xsd:enumeration value="IW"/>
			<xsd:enumeration value="IW1"/>
			<xsd:enumeration value="IW2"/>
			<xsd:enumeration value="IW3"/>
			<xsd:enumeration value="EW"/>
			<xsd:enumeration value="EW1"/>
			<xsd:enumeration value="EW2"/>
			<xsd:enumeration value="EW3"/>
			<xsd:enumeration value="EW4"/>
			<xsd:enumeration value="EW5"/>
			<xsd:enumeration value="WV"/>
			<xsd:enumeration value="WV1"/>
			<xsd:enumeration value="WV2"/>
			<xsd:enumeration value="EN"/>
			<xsd:enumeration value="N1"/>
			<xsd:enumeration value="N2"/>
			<xsd:enumeration value="N3"/>
			<xsd:enumeration value="N4"/>
			<xsd:enumeration value="N5"/>
			<xsd:enumeration value="N6"/>
			<xsd:enumeration value="RF"/>
			<xsd:enumeration value="IS1"/>
			<xsd:enumeration value="IS2"/>
			<xsd:enumeration value="IS3"/>
			<xsd:enumeration value="IS4"/>
			<xsd:enumeration value="IS5"/>
			<xsd:enumeration value="IS6"/>
			<xsd:enumeration value="IS7"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="timeType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef UTL_DateTime SPF_ObjectTypes_TimeType;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_TimeType&amp; value )
{
   UTL_DateTime_DateTimeString time;

   switch( op )
   {
      case XRW_Convert_OpToXml:
      {
         if ( UTL_DateTime_Sprint( value,
                                   UTL_DateTime_OutputFormat_CYMDTHMScu,
                                   time )
              != UTL_Const_success )
         {
            return UTL_Const_failure;
         }
         
         if( XRW_Convert_String( op, 
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 time, 
                                 UTL_DateTime_MaxDateTimeSize )
             != UTL_Const_success )
         {
            return UTL_Const_failure;
         }
         break;
      }
      case XRW_Convert_OpFromXml:
      {
         if( XRW_Convert_String( op, 
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 time, 
                                 UTL_DateTime_MaxDateTimeSize )
             != UTL_Const_success )
         {
            return UTL_Const_failure;
         }
         
         if ( UTL_DateTime_Sscan( time,
                                  UTL_DateTime_InputFormat_CYMDTHMScu,
                                  &amp;value )
              != UTL_Const_success )
         {
            return UTL_Const_failure;
         }
         break;
      }
      default:
      {
         return UTL_Const_failure;
      }
   }

   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:documentation>Time with respect to the specified reference time system. All times are with respect to UTC.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:dateTime"/>
	</xsd:simpleType>
	<xsd:simpleType name="topsFilterConventionType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of valid conventions for defining the TOPS ramping/de-ramping filter.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="All Lines"/>
			<xsd:enumeration value="Only Echo Lines"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="txPulseNumberType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Transmit pulse number.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="unsignedByte">
			<xsd:minInclusive value="0"/>
			<xsd:maxInclusive value="31"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="weightingWindowType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of weighting windwow names.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Kaiser"/>
			<xsd:enumeration value="Hamming"/>
			<xsd:enumeration value="None"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="bistaticDelayMethodType">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Enumeration of bi-static delay compensation methods.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="string">
			<xsd:enumeration value="Fine"/>
			<xsd:enumeration value="Coarse"/>
		</xsd:restriction>
	</xsd:simpleType>
	<!--
    ========================================================================
    = Primative type definitions
    ======================================================================== 
    -->
	<xsd:simpleType name="bool">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef bool SPF_ObjectTypes_Bool;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Boolean (true or false).</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:boolean">
			<xsd:pattern value="(false)|(true)"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="string">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef char SPF_ObjectTypes_String[SPF_ObjectTypes_StringLength];</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Character string containing up to 512 characters in UTF-8 encoding.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:string"/>
	</xsd:simpleType>
	<xsd:simpleType name="unsignedLong">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned long SPF_ObjectTypes_UnsignedLong;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>64 bit unsigned integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:nonNegativeInteger">
			<xsd:minInclusive value="0"/>
			<xsd:maxInclusive value="18446744073709551616"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="unsignedInt">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned int SPF_ObjectTypes_UnsignedInt;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>32 bit unsigned integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="unsignedLong">
			<xsd:minInclusive value="0"/>
			<xsd:maxInclusive value="4294967295"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="unsignedShort">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>16 bit unsigned integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="unsignedInt">
			<xsd:minInclusive value="0"/>
			<xsd:maxInclusive value="65535"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="unsignedByte">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>8 bit unsigned integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="unsignedShort">
			<xsd:minInclusive value="0"/>
			<xsd:maxInclusive value="255"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:complexType name="unitInteger">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Extension of the integer data type to include an optional "units" attribute.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="xsd:integer">
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="unitNonNegativeInteger">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>Extension of the nonNegativeInteger data type to include an optional "units" attribute.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="xsd:nonNegativeInteger">
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="int64">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef long SPF_ObjectTypes_Int64;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>64 bit signed integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="unitInteger">
				<xsd:minInclusive value="-9223372036854775808"/>
				<xsd:maxInclusive value="9223372036854775807"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="uint64">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned long long SPF_ObjectTypes_Uint64;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>64 bit unsigned integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="unitNonNegativeInteger">
				<xsd:minInclusive value="0"/>
				<xsd:maxInclusive value="18446744073709551616"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="int32">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef int SPF_ObjectTypes_Int32;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>32 bit signed integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="int64">
				<xsd:minInclusive value="-2147483648"/>
				<xsd:maxInclusive value="2147483647"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="uint32">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned int SPF_ObjectTypes_Uint32;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>32 bit unsigned integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="uint64">
				<xsd:minInclusive value="0"/>
				<xsd:maxInclusive value="4294967295"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="int16">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef short SPF_ObjectTypes_Int16;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>16 bit signed integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="int32">
				<xsd:minInclusive value="-32768"/>
				<xsd:maxInclusive value="32767"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="uint16">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned short SPF_ObjectTypes_Uint16;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>16 bit unsigned integer.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="uint32">
				<xsd:minInclusive value="0"/>
				<xsd:maxInclusive value="65535"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="byte">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef short SPF_ObjectTypes_Byte;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>8 bit signed byte.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="int16">
				<xsd:minInclusive value="-128"/>
				<xsd:maxInclusive value="127"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="ubyte">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef unsigned short SPF_ObjectTypes_Ubyte;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>8 bit unsigned byte.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:restriction base="uint16">
				<xsd:minInclusive value="0"/>
				<xsd:maxInclusive value="255"/>
			</xsd:restriction>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="float">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef float SPF_ObjectTypes_Float;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>32 bit single precision floating point number.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="xsd:float">
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="double">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: typedef double SPF_ObjectTypes_Double;</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: SKIP</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>64 bit double precision floating point number.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="xsd:double">
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="complex">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_Complex&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/re" );
   if( XRW_Convert( op, xmlTreeDescriptor, xmlFieldPath, value.re )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }

   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/im" );
   if( XRW_Convert( op, xmlTreeDescriptor, xmlFieldPath, value.im )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>64 bit complex number consisting of a 32 bit single precision floating point real part and a 32 bit single precision floating point imaginary part.</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="re" type="float">
				<xsd:annotation>
					<xsd:documentation>32 bit single precision floating point real number.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element name="im" type="float">
				<xsd:annotation>
					<xsd:documentation>32 bit single precision floating point imaginary number.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
	</xsd:complexType>
	<xsd:complexType name="uint64Array">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: struct SPF_ObjectTypes_Uint64Array
{
   unsigned long count;
   SPF_ObjectTypes_Uint64 values[SPF_ObjectTypes_MaxGroupedArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_Uint64Array&amp; value )
{
   if ( op == XRW_Convert_OpToXml )
   {
      if ( XRW_Convert( op,
                                xmlTreeDescriptor,
                                xmlPath )
           != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if ( XRW_Convert_GroupedArray( op,
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 value.values,
                                 (int)value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of 64 bit unsigned integer values separated by spaces. The mandatory count attribute defines the number of elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="intArray">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: struct SPF_ObjectTypes_IntArray
{
   unsigned long count;
   int values[SPF_ObjectTypes_MaxGroupedArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_IntArray&amp; value )
{
   if ( op == XRW_Convert_OpToXml )
   {
      if ( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
           != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if( XRW_Convert_GroupedArray( op,
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 value.values,
                                 (int)value.count )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of int values separated by spaces. The mandatory count attribute defines the number of elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="floatArray">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: struct SPF_ObjectTypes_FloatArray
{
   unsigned long count;
   float values[SPF_ObjectTypes_MaxGroupedArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_FloatArray&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if( XRW_Convert_GroupedArray( op,
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 value.values,
                                 (int)value.count )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of float values separated by spaces. The mandatory count attribute defines the number of elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="doubleArray">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: struct SPF_ObjectTypes_DoubleArray
{
   unsigned long count;
   double values[SPF_ObjectTypes_MaxGroupedArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_DoubleArray&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if( XRW_Convert_GroupedArray( op,
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 value.values,
                                 (int)value.count )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
         </xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of double precision floating point values separated by spaces. The mandatory count attribute defines the number of elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="floatCoefficientArray">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: const int SPF_ObjectTypes_MaxCoeffArrayLength = 22;
struct SPF_ObjectTypes_FloatCoefficientArray
{
   unsigned long count;
   float values[SPF_ObjectTypes_MaxCoeffArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_FloatCoefficientArray&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if( XRW_Convert_GroupedArray( op,
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 value.values,
                                 (int)value.count )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of float coefficient values separated by spaces. The mandatory count attribute defines the number of elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="doubleCoefficientArray">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: struct SPF_ObjectTypes_DoubleCoefficientArray
{
   unsigned long count;
   double values[SPF_ObjectTypes_MaxCoeffArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_DoubleCoefficientArray&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if( XRW_Convert_GroupedArray( op,
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 value.values,
                                 (int)value.count )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
         </xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of double precision floating point coefficient values separated by spaces. The mandatory count attribute defines the number of elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="complexArray">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: struct SPF_ObjectTypes_ComplexArray
{
   unsigned long count;
   PTL_FComplex values[SPF_ObjectTypes_MaxGroupedArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_ComplexArray&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }
   
   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if( XRW_Convert_GroupedArrayComplex( op,
                                        xmlTreeDescriptor,
                                        xmlPath,
                                        value.values,
                                        (int)value.count )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of complex value pairs separated by spaces in the form of I Q I Q I Q ... The mandatory count attribute defines the number of complex elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
	<xsd:complexType name="floatPatternArray">
		<xsd:annotation>
			<xsd:appinfo>CONVERT_TYPE_DEC: const int SPF_ObjectTypes_MaxPatternArrayLength = 4500;
struct SPF_ObjectTypes_FloatPatternArray
{
   unsigned long count;
   float values[SPF_ObjectTypes_MaxPatternArrayLength];
};</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEC: INSERT 
inline int XmlConvert( XRW_Convert_Op    op,
                       XRW_Convert_Tree* xmlTreeDescriptor,
                       const char*       xmlPath,
                       SPF_ObjectTypes_FloatPatternArray&amp; value )
{
   if( op == XRW_Convert_OpToXml )
   {
      if( XRW_Convert( op,
                       xmlTreeDescriptor,
                       xmlPath )
          != UTL_Const_success )
      {
         return UTL_Const_failure;
      }
   }

   char xmlFieldPath[XRW_Convert_MaxStringLength + 1];
   sprintf( xmlFieldPath,
            "%s%s",
            xmlPath,
            "/@count" );
   if ( XRW_Convert( op,
                    xmlTreeDescriptor,
                    xmlFieldPath,
                    value.count )
        != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   if( XRW_Convert_GroupedArray( op,
                                 xmlTreeDescriptor,
                                 xmlPath,
                                 value.values,
                                 (int)value.count )
       != UTL_Const_success )
   {
      return UTL_Const_failure;
   }
   
   return UTL_Const_success;
}
</xsd:appinfo>
			<xsd:appinfo>CONVERT_FUNC_DEF: SKIP</xsd:appinfo>
			<xsd:documentation>String containing an array of up to 4500 float values separated by spaces. The mandatory count attribute defines the number of elements in the array.</xsd:documentation>
		</xsd:annotation>
		<xsd:simpleContent>
			<xsd:extension base="string">
				<xsd:attribute name="count" type="unsignedInt" use="required"/>
				<xsd:attribute name="units" type="string" use="optional"/>
			</xsd:extension>
		</xsd:simpleContent>
	</xsd:complexType>
</xsd:schema>
